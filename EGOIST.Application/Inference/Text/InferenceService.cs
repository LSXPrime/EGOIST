using System.Runtime.CompilerServices;using System.Threading.Tasks.Dataflow;using EGOIST.Domain.Entities;using EGOIST.Domain.Interfaces;using LLama;using LLama.Abstractions;using LLama.Common;using static LLama.InteractiveExecutor;namespace EGOIST.Application.Inference.Text;public class InferenceService(ILLamaExecutor inference) : IInference{    public void Dispose()    {        switch (inference)        {            case StatefulExecutorBase statefulExecutor:                statefulExecutor.Context.Dispose();                statefulExecutor.ClipModel?.Dispose();                break;            case StatelessExecutor statelessExecutor:                statelessExecutor.Context.Dispose();                statelessExecutor.ClipModel?.Dispose();                break;        }    }    public async IAsyncEnumerable<T> Inference<T>(string prompt, IEnumerable<T> blacklist,        TextGenerationParameters parameters, [EnumeratorCancellation] CancellationToken cancellationToken)    {        var blacklistStr = (IReadOnlyList<string>)blacklist;        var messageParams = new InferenceParams        {            MaxTokens = parameters.MaxTokens,            Temperature = parameters.Randomness,            TopP = parameters.RandomnessBooster,            TopK = (int)(parameters.OptimalProbability * 100),            FrequencyPenalty = parameters.FrequencyPenalty,            AntiPrompts = blacklistStr        };        var tokens = inference.InferAsync(prompt, messageParams, cancellationToken);        await foreach (var token in tokens)        {            yield return blacklistStr.Any(x => token.Contains(x, StringComparison.CurrentCultureIgnoreCase))                ? (T)(object)"" //"FILTERING MECHANISM TRIGGERED"                : (T)(object)token;        }    }    public async IAsyncEnumerable<T> InferenceConcurrent<T>(string prompt, IEnumerable<T> blacklist,        TextGenerationParameters parameters, [EnumeratorCancellation] CancellationToken cancellationToken)    {        var messageParams = new InferenceParams()        {            MaxTokens = parameters.MaxTokens,            Temperature = parameters.Randomness,            TopP = parameters.RandomnessBooster,            TopK = (int)(parameters.OptimalProbability * 100),            FrequencyPenalty = parameters.FrequencyPenalty,            AntiPrompts = (IReadOnlyList<string>)blacklist        };                var tokens = (IAsyncEnumerable<T>)inference.InferAsync(prompt, messageParams, cancellationToken);        // Oh God, I've been using Unity for 6 years and executing everything on the main thread. Wtf am I doing here?        // Useless, I know, I will clean it up later        var bufferBlock = new BufferBlock<T>(new DataflowBlockOptions { CancellationToken = cancellationToken });        var actionBlock = new ActionBlock<T>(async token =>            {                if (blacklist.Any(x =>                        token!.ToString()!.Contains(x?.ToString()!, StringComparison.CurrentCultureIgnoreCase)))                {                    await bufferBlock.SendAsync((T)(object)"FILTERING MECHANISM TRIGGERED", cancellationToken);                    bufferBlock.Complete();                    cancellationToken.ThrowIfCancellationRequested();                }                else                {                    await bufferBlock.SendAsync(token, cancellationToken);                }            },            new ExecutionDataflowBlockOptions                { MaxDegreeOfParallelism = DataflowBlockOptions.Unbounded, CancellationToken = cancellationToken });        var linkOptions = new DataflowLinkOptions { PropagateCompletion = true };        bufferBlock.LinkTo(actionBlock, linkOptions);        await foreach (var token in tokens.WithCancellation(cancellationToken))        {            await actionBlock.SendAsync(token, cancellationToken);        }        actionBlock.Complete();        await actionBlock.Completion;        bufferBlock.Complete();        while (await bufferBlock.OutputAvailableAsync(cancellationToken))        {            var processedToken = await bufferBlock.ReceiveAsync(cancellationToken);            yield return processedToken;        }    }    public Task<bool> IsFirstRun(string type)    {        if (type == nameof(StatefulExecutorBase) && inference is StatefulExecutorBase executer)            return Task.FromResult(((InteractiveExecutorState)executer.GetStateData()).IsPromptRun);        return Task.FromResult(false);    }}